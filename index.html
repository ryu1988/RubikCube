<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rubik Ring — design first</title>
<style>
  :root{
    --bg0:#070b16; --bg1:#0a1633;
    --panel: rgba(255,255,255,0.06);
    --panel2: rgba(255,255,255,0.09);
    --line: rgba(255,255,255,0.10);
    --txt: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.70);

    --U:#f4f6fb; --D:#ffd44d; --F:#36d28a;
    --B:#4ea3ff; --L:#ff8a3d; --R:#ff4d5e;

    --radius: 18px;
    --sticker-gap: 10px;

    --glow: 0 0 0 3px rgba(255,255,255,0.16), 0 0 34px rgba(78,163,255,0.22);
    --soft: 0 24px 90px rgba(0,0,0,0.45);
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
    color:var(--txt);
    background:
      radial-gradient(1400px 760px at 18% 8%, rgba(78,163,255,0.18), transparent 60%),
      radial-gradient(900px 760px at 88% 22%, rgba(255,77,94,0.18), transparent 58%),
      radial-gradient(900px 900px at 55% 92%, rgba(54,210,138,0.16), transparent 62%),
      linear-gradient(160deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }

  .wrap{
    max-width: 1220px;
    margin: 0 auto;
    padding: 26px 18px 40px;
    display:grid;
    grid-template-columns: 1.2fr 0.8fr;
    gap: 18px;
    align-items:start;
  }

  header{
    grid-column:1/-1;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap: 14px;
    padding: 6px 4px 0;
  }
  h1{ margin:0; font-size: 22px; font-weight: 780; letter-spacing:.2px; }
  .sub{ margin:6px 0 0; color:var(--muted); font-size:13px; line-height:1.6; }
  .pillbar{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
  .pill{
    padding: 8px 10px;
    border: 1px solid var(--line);
    background: var(--panel);
    border-radius: 999px;
    font-size: 12px;
    color: var(--muted);
    backdrop-filter: blur(10px);
  }

  .card{
    border: 1px solid var(--line);
    background: linear-gradient(180deg, var(--panel), rgba(255,255,255,0.03));
    border-radius: var(--radius);
    box-shadow: var(--soft), 0 1px 0 rgba(255,255,255,0.05) inset;
    backdrop-filter: blur(12px);
  }

  /* ===== Ring stage ===== */
  .stage{
    position:relative;
    padding: 18px;
    min-height: 680px;
  }

  .ring{
    position:relative;
    width: 100%;
    height: 100%;
    min-height: 640px;
    display:block;

    /* sizing */
    --faceSize: clamp(170px, 22vw, 240px);
    --radiusRing: clamp(220px, 26vw, 320px);
  }

  /* background halo layers */
  .halo{
    position:absolute;
    inset: 50% auto auto 50%;
    transform: translate(-50%,-50%);
    width: calc(var(--radiusRing) * 2.2);
    height: calc(var(--radiusRing) * 2.2);
    border-radius: 999px;
    background:
      radial-gradient(circle at 50% 50%,
        rgba(78,163,255,0.0) 0%,
        rgba(78,163,255,0.08) 38%,
        rgba(78,163,255,0.0) 70%);
    filter: drop-shadow(0 0 40px rgba(78,163,255,0.14));
    pointer-events:none;
    z-index: 0;
  }

  .halo2{
    position:absolute;
    inset: 50% auto auto 50%;
    transform: translate(-50%,-50%);
    width: calc(var(--radiusRing) * 2.75);
    height: calc(var(--radiusRing) * 2.75);
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.07);
    box-shadow: 0 0 0 10px rgba(255,255,255,0.02) inset;
    opacity: 0.9;
    pointer-events:none;
    z-index: 0;
  }

  /* Face component */
  .face{
    position:absolute;
    width: var(--faceSize);
    height: var(--faceSize);
    padding: 14px;
    border-radius: 18px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,0.18);
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--sticker-gap);
    box-shadow: 0 18px 40px rgba(0,0,0,0.28);
    transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
    z-index: 2;
  }
  .face::before{
    content: attr(data-face);
    position:absolute;
    top: 10px; left: 12px;
    font-size: 11px;
    letter-spacing: 1.0px;
    color: rgba(255,255,255,0.62);
    text-transform: uppercase;
    pointer-events:none;
  }
  .face:hover{
    transform: translate(-50%,-50%) translateY(-2px);
    border-color: rgba(255,255,255,0.16);
    box-shadow: var(--soft), var(--glow);
  }

  .sticker{
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.10);
    box-shadow:
      0 10px 24px rgba(0,0,0,0.32),
      0 1px 0 rgba(255,255,255,0.12) inset;
    transition: transform .12s ease, filter .12s ease;
    transform: translateZ(0);
  }
  .sticker:hover{ transform: translateY(-2px); filter:saturate(1.06) contrast(1.02); }

  /* Position helpers: place face at polar angle around center */
  .at-center{ left:50%; top:50%; transform: translate(-50%,-50%); z-index: 3; }
  .at-ring{ left:50%; top:50%; transform: translate(-50%,-50%); }
  .at-ring[data-angle]{
    /* set by JS to translate outward */
  }

  /* Back face as OUTER halo face (always visible, subtle) */
  #face-B{
    left:50%; top:50%;
    transform: translate(-50%,-50%) scale(1.10);
    z-index: 1;
    opacity: 0.55;
    background: rgba(0,0,0,0.10);
    border-color: rgba(255,255,255,0.08);
    box-shadow:
      0 26px 100px rgba(0,0,0,0.55),
      0 0 0 12px rgba(78,163,255,0.06);
    pointer-events: none; /* Bは見せる専用（必要ならONにできる） */
  }
  #face-B::before{
    content:"B · BACK";
    opacity: 0.9;
    letter-spacing: 1.2px;
  }

  /* B placement: slightly behind and rotated by css illusion */
  #face-B{
    filter: saturate(1.05);
  }

  /* Connection hints: faint chords */
  svg#chords{
    position:absolute;
    inset: 0;
    width:100%;
    height:100%;
    pointer-events:none;
    z-index: 1;
    opacity: 0.95;
  }
  .chord{
    stroke: rgba(255,255,255,0.12);
    stroke-width: 2;
    fill: none;
    filter: drop-shadow(0 0 14px rgba(78,163,255,0.14));
  }
  .chordStrong{
    stroke: rgba(78,163,255,0.18);
    stroke-width: 2.2;
  }

  /* Right panel */
  .side{
    padding: 18px;
    display:flex;
    flex-direction:column;
    gap: 14px;
  }
  .section h2{
    margin:0 0 8px;
    font-size: 13px;
    letter-spacing: 0.6px;
    color: rgba(255,255,255,0.82);
    font-weight: 760;
  }
  .controls{ display:flex; flex-wrap:wrap; gap: 8px; }
  button{
    cursor:pointer;
    border: 1px solid var(--line);
    background: rgba(255,255,255,0.06);
    color: var(--txt);
    border-radius: 12px;
    padding: 10px 12px;
    font-size: 13px;
    transition: transform .12s ease, background .12s ease, border-color .12s ease;
    user-select:none;
    backdrop-filter: blur(10px);
  }
  button:hover{
    transform: translateY(-1px);
    background: rgba(255,255,255,0.10);
    border-color: rgba(255,255,255,0.18);
  }
  button:active{ transform: translateY(0px) scale(0.99); }

  .textarea{
    width: 100%;
    min-height: 84px;
    resize: vertical;
    border-radius: 14px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,0.22);
    color: var(--txt);
    padding: 10px 12px;
    font-size: 13px;
    outline: none;
  }
  .textarea:focus{
    border-color: rgba(255,255,255,0.22);
    box-shadow: 0 0 0 4px rgba(78,163,255,0.12);
  }

  .meta{
    display:flex; justify-content:space-between; gap:10px;
    color: var(--muted); font-size: 12px;
  }

  .toggle{
    display:flex; align-items:center; gap:10px;
    color: var(--muted); font-size:12px;
  }
  .toggle input{ width:18px; height:18px; accent-color:#4ea3ff; }

  @media (max-width: 980px){
    .wrap{ grid-template-columns: 1fr; }
    .stage{ min-height: 720px; }
    .ring{ --radiusRing: clamp(200px, 34vw, 320px); }
  }
</style>
</head>

<body>
<div class="wrap">
  <header>
    <div>
      <h1>Rubik Ring</h1>
      <p class="sub">回転なしで6面同時表示。<b>F中心</b>、U/R/D/Lを円環配置、Bは外周の“Back Halo”。</p>
    </div>
    <div class="pillbar">
      <div class="pill">UI: Ring layout</div>
      <div class="pill">Moves: R L U D F B / ' / 2</div>
      <div class="pill">Sequence: R U R' U'</div>
    </div>
  </header>

  <div class="card stage">
    <div class="ring" id="ring">
      <div class="halo" aria-hidden="true"></div>
      <div class="halo2" aria-hidden="true"></div>
      <svg id="chords" aria-hidden="true"></svg>

      <!-- Back face -->
      <div class="face at-center" data-face="B" id="face-B"></div>

      <!-- Center F -->
      <div class="face at-center" data-face="F" id="face-F"></div>

      <!-- Ring faces (placed by JS with angles) -->
      <div class="face at-ring" data-face="U" data-angle="-90" id="face-U"></div>
      <div class="face at-ring" data-face="R" data-angle="0" id="face-R"></div>
      <div class="face at-ring" data-face="D" data-angle="90" id="face-D"></div>
      <div class="face at-ring" data-face="L" data-angle="180" id="face-L"></div>
    </div>
  </div>

  <div class="card">
    <div class="side">
      <div class="section">
        <h2>Moves</h2>
        <div class="controls" id="moveButtons"></div>
        <div style="height:10px"></div>
        <div class="controls">
          <button id="btnScramble">Scramble (20)</button>
          <button id="btnReset">Reset</button>
          <button id="btnCheck">Solved?</button>
        </div>
        <div style="height:10px"></div>
        <label class="toggle">
          <input type="checkbox" id="toggleBack" checked />
          Show B as Back Halo
        </label>
        <label class="toggle">
          <input type="checkbox" id="toggleChords" checked />
          Show connection chords
        </label>
      </div>

      <div class="section">
        <h2>Sequence</h2>
        <textarea class="textarea" id="seq" spellcheck="false">R U R' U'</textarea>
        <div style="height:8px"></div>
        <div class="controls">
          <button id="btnRun">Run</button>
          <button id="btnRunSlow">Run Slow</button>
          <button id="btnClear">Clear</button>
        </div>
        <div style="height:10px"></div>
        <div class="meta">
          <div>Always visible: U L F R D + back B</div>
          <div id="moveCount">Moves: 0</div>
        </div>
      </div>

      <div class="section">
        <h2>Design hook</h2>
        <div style="color:var(--muted); font-size:12px; line-height:1.65">
          円環配置は「見た目の完成度」を上げやすいです。次は<br/>
          <b>回転前プレビュー（影響する列/辺の発光）</b>を追加すると、操作の分かりやすさも一気に上がります。
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Colors from CSS ===== */
const COLOR = {
  U: getComputedStyle(document.documentElement).getPropertyValue('--U').trim(),
  D: getComputedStyle(document.documentElement).getPropertyValue('--D').trim(),
  F: getComputedStyle(document.documentElement).getPropertyValue('--F').trim(),
  B: getComputedStyle(document.documentElement).getPropertyValue('--B').trim(),
  L: getComputedStyle(document.documentElement).getPropertyValue('--L').trim(),
  R: getComputedStyle(document.documentElement).getPropertyValue('--R').trim(),
};

/* ===== Cube model (3x3 stickers per face) ===== */
function solvedCube(){
  const c = {};
  for(const f of ["U","D","F","B","L","R"]) c[f] = Array(9).fill(f);
  return c;
}
let cube = solvedCube();
let moveCounter = 0;

function rotFaceCW(a){ return [a[6],a[3],a[0], a[7],a[4],a[1], a[8],a[5],a[2]]; }

function moveCW(face){
  const c = cube;
  const get = (f, idxs) => idxs.map(i => c[f][i]);
  const set = (f, idxs, vals) => idxs.forEach((i,k)=> c[f][i]=vals[k]);

  c[face] = rotFaceCW(c[face]);

  const cycles = {
    U: [["B",[0,1,2]],["R",[0,1,2]],["F",[0,1,2]],["L",[0,1,2]]],
    D: [["F",[6,7,8]],["R",[6,7,8]],["B",[6,7,8]],["L",[6,7,8]]],
    F: [["U",[6,7,8]],["R",[0,3,6]],["D",[2,1,0]],["L",[8,5,2]]],
    B: [["U",[2,1,0]],["L",[0,3,6]],["D",[6,7,8]],["R",[8,5,2]]],
    R: [["U",[2,5,8]],["B",[6,3,0]],["D",[2,5,8]],["F",[2,5,8]]],
    L: [["U",[0,3,6]],["F",[0,3,6]],["D",[0,3,6]],["B",[8,5,2]]],
  };

  const cyc = cycles[face];
  const temp = get(cyc[0][0], cyc[0][1]);
  for(let i=0;i<3;i++) set(cyc[i][0], cyc[i][1], get(cyc[i+1][0], cyc[i+1][1]));
  set(cyc[3][0], cyc[3][1], temp);
}

function applyMove(token){
  const m = token.trim();
  if(!m) return;
  const face = m[0];
  if(!"UDLRFB".includes(face)) return;

  let times = 1;
  let prime = false;
  if(m.endsWith("2")) times = 2;
  if(m.endsWith("'")) prime = true;
  if(prime) times = (times === 2) ? 2 : 3;

  for(let i=0;i<times;i++) moveCW(face);

  moveCounter++;
  document.getElementById("moveCount").textContent = `Moves: ${moveCounter}`;
  render();
}

function parseSequence(seq){
  const cleaned = seq.replace(/\n/g," ").trim();
  if(!cleaned) return [];
  let parts = cleaned.split(/\s+/).filter(Boolean);
  if(parts.length === 1) parts = cleaned.match(/[UDLRFB](?:'|2)?/g) ?? [];
  return parts;
}

function isSolved(){
  for(const f of ["U","D","F","B","L","R"]){
    if(!cube[f].every(x => x === cube[f][4])) return false;
  }
  return true;
}

/* ===== Render ===== */
function renderFace(face){
  const el = document.getElementById(`face-${face}`);
  el.innerHTML = "";
  for(let i=0;i<9;i++){
    const s = document.createElement("div");
    s.className = "sticker";
    const code = cube[face][i];
    s.style.background = `linear-gradient(180deg, ${COLOR[code]}, rgba(0,0,0,0.18))`;
    el.appendChild(s);
  }
}

function render(){
  for(const f of ["U","D","F","B","L","R"]) renderFace(f);
  layoutRingFaces();
  drawChords();
}

/* ===== Ring layout ===== */
function layoutRingFaces(){
  const ring = document.getElementById("ring");
  const styles = getComputedStyle(ring);
  const radius = parseFloat(styles.getPropertyValue('--radiusRing')) || 280;

  for(const f of ["U","R","D","L"]){
    const el = document.getElementById(`face-${f}`);
    const angleDeg = parseFloat(el.dataset.angle);
    const rad = (angleDeg * Math.PI) / 180;

    // subtle perspective offset: slightly ellipse
    const rx = radius * 1.05;
    const ry = radius * 0.86;

    const x = Math.cos(rad) * rx;
    const y = Math.sin(rad) * ry;

    el.style.left = "50%";
    el.style.top = "50%";
    el.style.transform = `translate(-50%,-50%) translate(${x}px, ${y}px)`;
  }

  // B as back halo: keep centered, already styled
  const back = document.getElementById("face-B");
  back.style.left = "50%";
  back.style.top = "50%";
  back.style.transform = "translate(-50%,-50%) scale(1.10)";
}

/* ===== Connection chords (visual adjacency hints) =====
   Draw chords from F center to U/R/D/L centers, and a larger faint ring for B. */
function drawChords(){
  const svg = document.getElementById("chords");
  const on = document.getElementById("toggleChords").checked;
  svg.style.display = on ? "block" : "none";
  if(!on) return;

  svg.innerHTML = "";

  const ring = document.getElementById("ring");
  const rrect = ring.getBoundingClientRect();

  const centerOf = (id)=>{
    const el = document.getElementById(id);
    const rect = el.getBoundingClientRect();
    return { x: rect.left + rect.width/2 - rrect.left, y: rect.top + rect.height/2 - rrect.top };
  };

  const pF = centerOf("face-F");
  const points = ["face-U","face-R","face-D","face-L"].map(centerOf);

  svg.setAttribute("viewBox", `0 0 ${rrect.width} ${rrect.height}`);
  svg.setAttribute("preserveAspectRatio","none");

  // soft ring circle behind (design)
  const ringCircle = document.createElementNS("http://www.w3.org/2000/svg","circle");
  ringCircle.setAttribute("cx", pF.x);
  ringCircle.setAttribute("cy", pF.y);
  ringCircle.setAttribute("r", Math.min(rrect.width, rrect.height) * 0.33);
  ringCircle.setAttribute("class", "chord chordStrong");
  ringCircle.setAttribute("opacity", "0.35");
  svg.appendChild(ringCircle);

  // chords
  for(const p of points){
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    const dx = p.x - pF.x, dy = p.y - pF.y;
    const c1 = { x: pF.x + dx*0.35, y: pF.y + dy*0.05 };
    const c2 = { x: pF.x + dx*0.65, y: pF.y + dy*0.95 };
    path.setAttribute("d", `M ${pF.x} ${pF.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${p.x} ${p.y}`);
    path.setAttribute("class","chord");
    svg.appendChild(path);
  }
}

/* ===== Controls ===== */
const MOVE_KEYS = ["R","L","U","D","F","B"];
const moveButtons = document.getElementById("moveButtons");
for(const m of MOVE_KEYS){
  const b1 = document.createElement("button"); b1.textContent = m; b1.onclick = ()=> applyMove(m);
  const b2 = document.createElement("button"); b2.textContent = `${m}'`; b2.onclick = ()=> applyMove(`${m}'`);
  const b3 = document.createElement("button"); b3.textContent = `${m}2`; b3.onclick = ()=> applyMove(`${m}2`);
  moveButtons.appendChild(b1); moveButtons.appendChild(b2); moveButtons.appendChild(b3);
}

document.getElementById("btnReset").onclick = ()=>{
  cube = solvedCube();
  moveCounter = 0;
  document.getElementById("moveCount").textContent = `Moves: ${moveCounter}`;
  render();
};

document.getElementById("btnCheck").onclick = ()=> alert(isSolved() ? "Solved ✅" : "Not yet");

document.getElementById("btnClear").onclick = ()=> document.getElementById("seq").value = "";

document.getElementById("btnScramble").onclick = ()=>{
  const faces = ["R","L","U","D","F","B"];
  const suffix = ["","'","2"];
  const seq = [];
  let prev = "";
  for(let i=0;i<20;i++){
    let f;
    do { f = faces[(Math.random()*faces.length)|0]; } while(f===prev);
    prev = f;
    seq.push(f + suffix[(Math.random()*suffix.length)|0]);
  }
  document.getElementById("seq").value = seq.join(" ");
};

async function runSequence(seq, delayMs=0){
  const tokens = parseSequence(seq);
  for(const t of tokens){
    applyMove(t);
    if(delayMs) await new Promise(r=>setTimeout(r,delayMs));
  }
}
document.getElementById("btnRun").onclick = ()=> runSequence(document.getElementById("seq").value, 0);
document.getElementById("btnRunSlow").onclick = ()=> runSequence(document.getElementById("seq").value, 160);

document.getElementById("toggleBack").addEventListener("change", (e)=>{
  const on = e.target.checked;
  document.getElementById("face-B").style.display = on ? "grid" : "none";
});

document.getElementById("toggleChords").addEventListener("change", ()=> drawChords());
window.addEventListener("resize", ()=> setTimeout(()=>{ layoutRingFaces(); drawChords(); }, 0));

/* init */
render();
</script>
</body>
</html>
