<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Rubik Cross — always visible</title>
<style>
  :root{
    --bg0:#0b1020; --bg1:#0a1633;
    --panel: rgba(255,255,255,0.06);
    --line: rgba(255,255,255,0.10);
    --txt: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.70);

    --U:#f4f6fb; --D:#ffd44d; --F:#36d28a;
    --B:#4ea3ff; --L:#ff8a3d; --R:#ff4d5e;

    --radius: 18px;
    --sticker-gap: 10px;
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
    color:var(--txt);
    background:
      radial-gradient(1200px 600px at 15% 10%, #2443aa33, transparent 60%),
      radial-gradient(900px 700px at 90% 20%, #ff4d5e22, transparent 55%),
      radial-gradient(800px 800px at 60% 90%, #36d28a22, transparent 60%),
      linear-gradient(160deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }

  .wrap{
    max-width: 1200px;
    margin: 0 auto;
    padding: 26px 18px 40px;
    display:grid;
    grid-template-columns: 1.15fr 0.85fr;
    gap: 18px;
    align-items:start;
  }
  header{
    grid-column:1/-1;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap: 14px;
    padding: 8px 4px 0;
  }
  h1{ margin:0; font-size: 22px; font-weight: 760; letter-spacing: .2px; }
  .sub{ margin:6px 0 0; color:var(--muted); font-size:13px; line-height:1.6; }
  .pillbar{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
  .pill{
    padding: 8px 10px;
    border: 1px solid var(--line);
    background: var(--panel);
    border-radius: 999px;
    font-size: 12px;
    color: var(--muted);
    backdrop-filter: blur(10px);
  }

  .card{
    border: 1px solid var(--line);
    background: linear-gradient(180deg, var(--panel), rgba(255,255,255,0.03));
    border-radius: var(--radius);
    box-shadow:
      0 20px 80px rgba(0,0,0,0.35),
      0 1px 0 rgba(255,255,255,0.05) inset;
    backdrop-filter: blur(12px);
  }

  /* ====== Cross layout stage ====== */
  .stage{
    position:relative;
    padding: 18px;
    min-height: 620px;
  }

  /* Cross metrics */
  .cross{
    position:relative;
    width: 100%;
    height: 100%;
    display:block;
  }
  /* responsive face size */
  .cross{
    --faceSize: clamp(190px, 22vw, 240px);
    --gap: clamp(16px, 2.2vw, 26px);
  }

  /* Face component */
  .face{
    position:absolute;
    width: var(--faceSize);
    height: var(--faceSize);
    padding: 14px;
    border-radius: 18px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,0.18);
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--sticker-gap);
    box-shadow: 0 18px 40px rgba(0,0,0,0.28);
  }
  .face::before{
    content: attr(data-face);
    position:absolute;
    top: 10px; left: 12px;
    font-size: 11px;
    letter-spacing: 0.9px;
    color: rgba(255,255,255,0.62);
    text-transform: uppercase;
    pointer-events:none;
  }

  .sticker{
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.10);
    box-shadow:
      0 10px 24px rgba(0,0,0,0.32),
      0 1px 0 rgba(255,255,255,0.12) inset;
    transition: transform .12s ease, filter .12s ease;
    transform: translateZ(0);
  }
  .sticker:hover{ transform: translateY(-2px); filter:saturate(1.06) contrast(1.02); }

  /* Cross positions: center = F */
  #face-F{
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    z-index: 3;
  }
  #face-U{
    left: 50%;
    top: calc(50% - var(--faceSize) - var(--gap));
    transform: translateX(-50%);
    z-index: 3;
  }
  #face-D{
    left: 50%;
    top: calc(50% + var(--faceSize) + var(--gap));
    transform: translateX(-50%);
    z-index: 3;
  }
  #face-L{
    left: calc(50% - var(--faceSize) - var(--gap));
    top: 50%;
    transform: translateY(-50%);
    z-index: 3;
  }
  #face-R{
    left: calc(50% + var(--faceSize) + var(--gap));
    top: 50%;
    transform: translateY(-50%);
    z-index: 3;
  }

  /* Back face as a "halo" behind the cross (always visible) */
  #face-B{
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%) scale(1.12);
    z-index: 1;
    opacity: 0.62;
    background: rgba(0,0,0,0.10);
    border-color: rgba(255,255,255,0.08);
    box-shadow:
      0 26px 90px rgba(0,0,0,0.40),
      0 0 0 10px rgba(78,163,255,0.06);
    filter: blur(0.0px);
    pointer-events: none; /* 背面はクリック不要（見せる専用） */
  }
  #face-B::before{
    content:"B (BACK)";
    letter-spacing: 1.2px;
    opacity: 0.85;
  }

  /* Subtle connectors (design hint) */
  .connector{
    position:absolute;
    left:50%; top:50%;
    width: 2px; height: 2px;
    z-index: 2;
    pointer-events:none;
  }
  .beam{
    position:absolute;
    background: linear-gradient(180deg, rgba(78,163,255,0.00), rgba(78,163,255,0.22), rgba(78,163,255,0.00));
    filter: drop-shadow(0 0 10px rgba(78,163,255,0.22));
    opacity: 0.75;
    border-radius: 999px;
  }
  .beam.h{ height: 6px; }
  .beam.v{ width: 6px; }

  /* Right panel */
  .side{
    padding: 18px;
    display:flex;
    flex-direction:column;
    gap: 14px;
  }
  .section h2{
    margin:0 0 8px;
    font-size: 13px;
    letter-spacing: 0.6px;
    color: rgba(255,255,255,0.80);
    font-weight: 750;
  }
  .controls{ display:flex; flex-wrap:wrap; gap: 8px; }
  button{
    cursor:pointer;
    border: 1px solid var(--line);
    background: rgba(255,255,255,0.06);
    color: var(--txt);
    border-radius: 12px;
    padding: 10px 12px;
    font-size: 13px;
    transition: transform .12s ease, background .12s ease, border-color .12s ease;
    user-select:none;
    backdrop-filter: blur(10px);
  }
  button:hover{
    transform: translateY(-1px);
    background: rgba(255,255,255,0.10);
    border-color: rgba(255,255,255,0.18);
  }
  button:active{ transform: translateY(0px) scale(0.99); }

  .textarea{
    width: 100%;
    min-height: 84px;
    resize: vertical;
    border-radius: 14px;
    border: 1px solid var(--line);
    background: rgba(0,0,0,0.22);
    color: var(--txt);
    padding: 10px 12px;
    font-size: 13px;
    outline: none;
  }
  .textarea:focus{
    border-color: rgba(255,255,255,0.22);
    box-shadow: 0 0 0 4px rgba(78,163,255,0.12);
  }

  .meta{
    display:flex; justify-content:space-between; gap:10px;
    color: var(--muted); font-size: 12px;
  }

  .toggle{
    display:flex; align-items:center; gap:10px;
    color: var(--muted); font-size:12px;
  }
  .toggle input{ width:18px; height:18px; accent-color:#4ea3ff; }

  @media (max-width: 980px){
    .wrap{ grid-template-columns: 1fr; }
    .stage{ min-height: 640px; }
    #face-R{ top: calc(50% + var(--faceSize) + var(--gap)); left: 50%; transform: translateX(-50%); }
    #face-L{ top: calc(50% - var(--faceSize) - var(--gap)); left: 50%; transform: translateX(-50%); }
    /* 小画面は縦に寄せる（見切れ回避） */
  }
</style>
</head>

<body>
<div class="wrap">
  <header>
    <div>
      <h1>Rubik Cross</h1>
      <p class="sub">回転なしで6面同時表示。<b>Fを中心</b>に U/L/R/D を配置し、Bは<b>背後のゴースト面</b>として常時可視化。</p>
    </div>
    <div class="pillbar">
      <div class="pill">UI: Cross + Back Halo</div>
      <div class="pill">Moves: R L U D F B / ' / 2</div>
      <div class="pill">Input: R U R' U'</div>
    </div>
  </header>

  <div class="card stage">
    <div class="cross" id="cross">
      <!-- subtle beams to suggest adjacency -->
      <div class="connector" aria-hidden="true">
        <div class="beam v" style="left:-3px; top: calc(-1*(var(--faceSize) + var(--gap)) + 18px); height: calc(var(--faceSize) + var(--gap) - 20px);"></div>
        <div class="beam v" style="left:-3px; top: 18px; height: calc(var(--faceSize) + var(--gap) - 20px);"></div>
        <div class="beam h" style="top:-3px; left: calc(-1*(var(--faceSize) + var(--gap)) + 18px); width: calc(var(--faceSize) + var(--gap) - 20px);"></div>
        <div class="beam h" style="top:-3px; left: 18px; width: calc(var(--faceSize) + var(--gap) - 20px);"></div>
      </div>

      <!-- Faces (B behind) -->
      <div class="face" data-face="B" id="face-B"></div>
      <div class="face" data-face="U" id="face-U"></div>
      <div class="face" data-face="L" id="face-L"></div>
      <div class="face" data-face="F" id="face-F"></div>
      <div class="face" data-face="R" id="face-R"></div>
      <div class="face" data-face="D" id="face-D"></div>
    </div>
  </div>

  <div class="card">
    <div class="side">
      <div class="section">
        <h2>Moves</h2>
        <div class="controls" id="moveButtons"></div>
        <div style="height:10px"></div>
        <div class="controls">
          <button id="btnScramble">Scramble (20)</button>
          <button id="btnReset">Reset</button>
          <button id="btnCheck">Solved?</button>
        </div>
        <div style="height:10px"></div>
        <label class="toggle">
          <input type="checkbox" id="toggleBack" checked />
          Show B as “Back Halo”
        </label>
      </div>

      <div class="section">
        <h2>Sequence</h2>
        <textarea class="textarea" id="seq" spellcheck="false">R U R' U'</textarea>
        <div style="height:8px"></div>
        <div class="controls">
          <button id="btnRun">Run</button>
          <button id="btnRunSlow">Run Slow</button>
          <button id="btnClear">Clear</button>
        </div>
        <div style="height:10px"></div>
        <div class="meta">
          <div>Always visible: U L F R D + back B</div>
          <div id="moveCount">Moves: 0</div>
        </div>
      </div>

      <div class="section">
        <h2>Next (recommended)</h2>
        <div style="color:var(--muted); font-size:12px; line-height:1.65">
          この配置は「隣接が直感的」なので、次は<br/>
          <b>回転前プレビュー（影響する辺/列を発光）</b>を足すとさらに分かりやすくなります。
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Cube model (same as before) ===== */
const COLOR = {
  U: getComputedStyle(document.documentElement).getPropertyValue('--U').trim(),
  D: getComputedStyle(document.documentElement).getPropertyValue('--D').trim(),
  F: getComputedStyle(document.documentElement).getPropertyValue('--F').trim(),
  B: getComputedStyle(document.documentElement).getPropertyValue('--B').trim(),
  L: getComputedStyle(document.documentElement).getPropertyValue('--L').trim(),
  R: getComputedStyle(document.documentElement).getPropertyValue('--R').trim(),
};

function solvedCube(){
  const c = {};
  for(const f of ["U","D","F","B","L","R"]) c[f] = Array(9).fill(f);
  return c;
}

let cube = solvedCube();
let moveCounter = 0;

function rotFaceCW(a){ return [a[6],a[3],a[0], a[7],a[4],a[1], a[8],a[5],a[2]]; }

function moveCW(face){
  const c = cube;
  const get = (f, idxs) => idxs.map(i => c[f][i]);
  const set = (f, idxs, vals) => idxs.forEach((i,k)=> c[f][i]=vals[k]);

  c[face] = rotFaceCW(c[face]);

  const cycles = {
    U: [["B",[0,1,2]],["R",[0,1,2]],["F",[0,1,2]],["L",[0,1,2]]],
    D: [["F",[6,7,8]],["R",[6,7,8]],["B",[6,7,8]],["L",[6,7,8]]],
    F: [["U",[6,7,8]],["R",[0,3,6]],["D",[2,1,0]],["L",[8,5,2]]],
    B: [["U",[2,1,0]],["L",[0,3,6]],["D",[6,7,8]],["R",[8,5,2]]],
    R: [["U",[2,5,8]],["B",[6,3,0]],["D",[2,5,8]],["F",[2,5,8]]],
    L: [["U",[0,3,6]],["F",[0,3,6]],["D",[0,3,6]],["B",[8,5,2]]],
  };

  const cyc = cycles[face];
  const temp = get(cyc[0][0], cyc[0][1]);
  for(let i=0;i<3;i++) set(cyc[i][0], cyc[i][1], get(cyc[i+1][0], cyc[i+1][1]));
  set(cyc[3][0], cyc[3][1], temp);
}

function applyMove(token){
  const m = token.trim();
  if(!m) return;
  const face = m[0];
  if(!"UDLRFB".includes(face)) return;

  let times = 1;
  let prime = false;
  if(m.endsWith("2")) times = 2;
  if(m.endsWith("'")) prime = true;
  if(prime) times = (times === 2) ? 2 : 3;

  for(let i=0;i<times;i++) moveCW(face);

  moveCounter++;
  document.getElementById("moveCount").textContent = `Moves: ${moveCounter}`;
  render();
}

function parseSequence(seq){
  const cleaned = seq.replace(/\n/g," ").trim();
  if(!cleaned) return [];
  let parts = cleaned.split(/\s+/).filter(Boolean);
  if(parts.length === 1) parts = cleaned.match(/[UDLRFB](?:'|2)?/g) ?? [];
  return parts;
}

function isSolved(){
  for(const f of ["U","D","F","B","L","R"]){
    if(!cube[f].every(x => x === cube[f][4])) return false;
  }
  return true;
}

/* ===== Render ===== */
function renderFace(face){
  const el = document.getElementById(`face-${face}`);
  el.innerHTML = "";
  for(let i=0;i<9;i++){
    const s = document.createElement("div");
    s.className = "sticker";
    const code = cube[face][i];
    s.style.background = `linear-gradient(180deg, ${COLOR[code]}, rgba(0,0,0,0.18))`;
    el.appendChild(s);
  }
}
function render(){
  for(const f of ["U","D","F","B","L","R"]) renderFace(f);
}

/* ===== Controls ===== */
const MOVE_KEYS = ["R","L","U","D","F","B"];
const moveButtons = document.getElementById("moveButtons");
for(const m of MOVE_KEYS){
  const b1 = document.createElement("button"); b1.textContent = m; b1.onclick = ()=> applyMove(m);
  const b2 = document.createElement("button"); b2.textContent = `${m}'`; b2.onclick = ()=> applyMove(`${m}'`);
  const b3 = document.createElement("button"); b3.textContent = `${m}2`; b3.onclick = ()=> applyMove(`${m}2`);
  moveButtons.appendChild(b1); moveButtons.appendChild(b2); moveButtons.appendChild(b3);
}

document.getElementById("btnReset").onclick = ()=>{
  cube = solvedCube();
  moveCounter = 0;
  document.getElementById("moveCount").textContent = `Moves: ${moveCounter}`;
  render();
};

document.getElementById("btnCheck").onclick = ()=> alert(isSolved() ? "Solved ✅" : "Not yet");

document.getElementById("btnClear").onclick = ()=> document.getElementById("seq").value = "";

document.getElementById("btnScramble").onclick = ()=>{
  const faces = ["R","L","U","D","F","B"];
  const suffix = ["","'","2"];
  const seq = [];
  let prev = "";
  for(let i=0;i<20;i++){
    let f;
    do { f = faces[(Math.random()*faces.length)|0]; } while(f===prev);
    prev = f;
    seq.push(f + suffix[(Math.random()*suffix.length)|0]);
  }
  document.getElementById("seq").value = seq.join(" ");
};

async function runSequence(seq, delayMs=0){
  const tokens = parseSequence(seq);
  for(const t of tokens){
    applyMove(t);
    if(delayMs) await new Promise(r=>setTimeout(r,delayMs));
  }
}
document.getElementById("btnRun").onclick = ()=> runSequence(document.getElementById("seq").value, 0);
document.getElementById("btnRunSlow").onclick = ()=> runSequence(document.getElementById("seq").value, 160);

document.getElementById("toggleBack").addEventListener("change", (e)=>{
  const on = e.target.checked;
  const b = document.getElementById("face-B");
  b.style.display = on ? "grid" : "none";
});

render();
</script>
</body>
</html>
